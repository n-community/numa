from google.appengine.ext import db
import re
import random
import os
import datetime

import lib
from .setproperty import SetProperty
from .user        import User
from .tag         import Tag, TagJoin
from .sequence    import Sequence

class InvalidMapError(Exception): pass


class DuplicateVoteError(Exception): pass


class Map(db.Model):
  RATING_THRESHOLD = 5
  MAX_RATING = 5

  RESERVED_TAGS = set([u"rated", u"unrated", u"bitesized", u"author", u"title",
                       u"favorites", u"starred", u"featured", u"delisted"])
  TAG_RE = re.compile("^[a-zA-Z0-9.-]+$")
  FLOAT_DELTAS = {
    0: -2,
    1: -1,
    2: 0,
    3: 0,
    4: 1,
    5: 2,
  }

  float_num = db.IntegerProperty(required=True)
  name = db.StringProperty()
  description = db.TextProperty()
  mapdata = db.TextProperty(required=True)
  lastupdated = db.DateTimeProperty(required=True, auto_now_add=True)
  created = db.DateTimeProperty(required=True, auto_now_add=True)
  user = db.ReferenceProperty(User, collection_name="maps")
  rating = db.FloatProperty(required=True, default=0.0)
  votes = db.IntegerProperty(required=True, default=0)
  disableratings = db.BooleanProperty(required=True, default=False)
  unlisted = db.BooleanProperty(required=True, default=False)
  moderator_unlisted = db.BooleanProperty(required=True, default=False)
  reported = db.BooleanProperty(required=True, default=False)
  reported_by = db.ReferenceProperty(User, collection_name="reported_maps")
  tags = SetProperty(str, default=set([u"unrated"]))
  category = db.StringProperty()
  image_url = db.StringProperty(indexed=False)

  # Autogenerated properties
  mapdata_hash = db.StringProperty(required=True)
  rated = db.BooleanProperty(required=True, default=False)
  random = db.FloatProperty(required=True)
  comment_count = db.IntegerProperty(default=0)

  # Featured map status
  featured_date = db.DateTimeProperty()
  featured_by = db.ReferenceProperty(User, collection_name="reviewed_maps")
  featured_text = db.TextProperty()

  # Timestamp of the first comment the author hasn't read.
  first_unread_comment = db.DateTimeProperty()

  def __init__(self, *args, **kwargs):
    super(Map, self).__init__(*args, **kwargs)
    self.random = random.random()

  @staticmethod
  def get_key_name(mapid):
    return "_%d" % mapid

  @staticmethod
  def get_key(mapid):
    return db.Key.from_path("Map", Map.get_key_name(mapid))

  @staticmethod
  def get_by_map_id(mapid):
    return Map.get_by_key_name(Map.get_key_name(mapid))

  def _get__map_id(self):
    return int(self.key().name()[1:])
  map_id = property(_get__map_id)

  def GetRoundedRating(self):
    return int(round(self.rating))

  def IsRated(self):
    return self.votes >= Map.RATING_THRESHOLD

  def VotesRequired(self):
    return Map.RATING_THRESHOLD - self.votes

  def RecordVote(self, user_key, rating, delta=1):
    map_key = self.key()

    def DoUpdateMap():
      vote_key = db.Key.from_path("Map", map_key.name(),
                                  "Vote", user_key.name())
      vote = Vote.get(vote_key)
      if vote: raise DuplicateVoteError()

      map = Map.get(map_key)
      old_bar = new_bar = None
      # if map.rated:
      #   old_bar = min(int((map.rating / Map.MAX_RATING) * User.HISTOGRAM_SIZE),
      #                 User.HISTOGRAM_SIZE - 1)
      map.rating = (map.rating * map.votes + rating) / (map.votes + delta)
      map.votes += delta
      map.rated = (map.votes >= Map.RATING_THRESHOLD)
      if map.rated:
        # new_bar = min(int((map.rating / Map.MAX_RATING) * User.HISTOGRAM_SIZE),
        #               User.HISTOGRAM_SIZE - 1)
        if "rated" not in map.tags:
          map.tags.discard(u"unrated")
          map.tags.add(u"rated")
      elif "unrated" not in map.tags:
        map.tags.discard(u"rated")
        map.tags.add(u"unrated")
      map.float_num += delta * Map.FLOAT_DELTAS[rating]
      map.put()

      Vote(parent=map,
           key_name=user_key.name(),
           value=rating).put()

      return (old_bar, new_bar,
              (map.votes >= Map.RATING_THRESHOLD)
              != (map.votes >= Map.RATING_THRESHOLD))

    def DoUpdateUser(old_bar, new_bar, change_rated_count):
      user = User.get(self.user.key())
      # if old_bar: user.rating_histogram[old_bar] -= abs(delta)/delta
      # if new_bar: user.rating_histogram[new_bar] += abs(delta)/delta
      user.ratings += delta
      if change_rated_count:
        user.rated_map_count += delta
      user.put()

    try:
      old_bar, new_bar, change_rated_count = db.run_in_transaction(DoUpdateMap)
      db.run_in_transaction(DoUpdateUser, old_bar, new_bar, change_rated_count)
    except DuplicateVoteError:
      pass

  def RemoveVote(self, rating):
    self.RecordVote(-rating, -1)

  def AddStar(self, user_key):
    map_key = self.key()
    def DoAddStar():
      fav = Favorite.get_by_key_name(map_key.name(), parent=user_key)
      if not fav:
        user = User.get(user_key)
        user.favourite_count += 1
        fav = Favorite(key_name=map_key.name(), parent=user, map_id=self.map_id)
        db.put(user)
        db.put(fav)

    db.run_in_transaction(DoAddStar)

  def RemoveStar(self, user_key):
    map_key = self.key()
    def DoRemoveStar():
      fav = Favorite.get_by_key_name(map_key.name(), parent=user_key)
      if fav:
        user = User.get(user_key)
        user.favourite_count -= 1
        user.put()
        fav.delete()

    db.run_in_transaction(DoRemoveStar)

  def SwapReviewSlot(self, other):
    self.featured_date, other.featured_date = other.featured_date, self.featured_date
    self.put()
    other.put()

  def GetExtendedTags(self):
    return sorted(self.tags)

  def GetUserTags(self):
    user_tags = set(self.tags - Map.RESERVED_TAGS)
    author_tag = Tag.normalise(u"author:%s" % (self.user.username,))
    user_tags.discard(author_tag)
    return sorted(user_tags)

  def SetTags(self, tag_list):
    author_tag = Tag.normalise(u"author:%s" % (self.user.username,))
    tags = (set([x for x in tag_list if Map.TAG_RE.search(x)][:5])
            - Map.RESERVED_TAGS)
    old_tags = set(self.tags)
    old_tags.discard(author_tag)
    new_tags = set(tags)

    # Update tag join counts
    # These are used for suggestions, so exclude reserved tags
    old_tagjoins = set(TagJoin.GetPowerset(list(old_tags - Map.RESERVED_TAGS)[:5]))
    new_tagjoins = set(TagJoin.GetPowerset(list(tags)))

    new_tags.update(old_tags.intersection(Map.RESERVED_TAGS))
    new_tags.add(author_tag)

    # Process added tags
    modified_tags = []
    for tag_name in new_tags - old_tags:
      if Tag.normalise(tag_name):
        tag = Tag.get_or_insert_tag(tag_name)
        tag.count += 1
        modified_tags.append(tag)
    # Process removed tags
    for tag_name in old_tags - new_tags:
      if Tag.normalise(tag_name):
        tag = Tag.get_or_insert_tag(tag_name)
        tag.count -= 1
        modified_tags.append(tag)
    if modified_tags:
      db.put(modified_tags)

    # Process modified tagjoins
    TagJoin.update_joins(new_tagjoins, old_tagjoins, 20)

    self.tags = new_tags
    if tag_list:
      self.category = tag_list[0]
    else:
      self.category = None

  object_info = {
    "0": {"pcount": 2},
    "1": {"pcount": 2},
    "2": {"pcount": 4},
    "3": {"pcount": 2},
    "4": {"pcount": 3},
    "5": {"pcount": 2},
    "6": {"pcount": 6},
    "7": {"pcount": 3},
    "8": {"pcount": 3},
    "9": {"pcount": 9},
    "10": {"pcount": 2},
    "11": {"pcount": 4},
    "12": {"pcount": 2},
  }

  @staticmethod
  def ValidateMapData(data):
    if data.startswith("$"):
      data = data.split("#")[-2]

    try:
      terrain, objects = data.split("|")[:2]
      if len(terrain) != 713:
        raise InvalidMapError("Incorrect number of characters before '|' symbol.")
    except ValueError:
      raise InvalidMapError("Map data must contain at least one '|'")

    objects = objects.split("!")
    for obj in objects:
      obj = obj.split("^")
      if not len(obj[0]):
        raise InvalidMapError("No objectid for object")
      if len(obj) == 1 or not len(obj[1]):
        raise InvalidMapError("No object data for object with id '%s'" % objectid)
      objectdata = obj[1].split(",")
      if len(objectdata) != Map.object_info[obj[0]]["pcount"]:
        raise InvalidMapError("Incorrect parameter count for object with id '%s':"
                              "Expected %d, got %d" % (len(objectdata),
                                                       Map.object_info[obj[0]]["pcount"]))

    return data

  def MarkAsRead(self):
    def DoClearFirstUnread():
      map = Map.get(self.key())
      if map.first_unread_comment:
        map.first_unread_comment = None
        map.put()
        return True
      else:
        return False

    def DoDecrementUnreadCount():
      user = User.get(self._user)
      if user.num_unread_maps > 0:
        user.num_unread_maps -= 1
        user.put()

    if db.RunInTransaction(DoClearFirstUnread):
      db.RunInTransaction(DoDecrementUnreadCount)

  def GetMapdata(self):
    return "$%s#%s#%s#%s#" % (lib.nify_str(self.name),
                              lib.nify_str(self.user.username),
                              lib.nify_str(self.category or "none"),
                              lib.nify_str(self.mapdata))

  def IsFeatured(self):
    """Is the map featured as far as the site is concerned?

    This will return False for maps queued up to be Featured in the future."""
    return self.featured_date and self.featured_date <= datetime.datetime.utcnow()

def ReadBadwords():
  f = open(os.path.join(os.path.dirname(__file__), "..", "badwords.txt"), "r")
  ret = set([x.lower().strip() for x in f])
  f.close()
  return ret

class Comment(db.Model):
  _badwords = ReadBadwords()

  author = db.ReferenceProperty(User, required=True)
  title = db.StringProperty(multiline=True)
  text = db.TextProperty()
  demodata = db.TextProperty()
  lastupdated = db.DateTimeProperty(required=True, auto_now_add=True)
  reported = db.BooleanProperty(required=True, default=False)
  reported_by = db.ReferenceProperty(User, collection_name="reported_comments")

  demo_re = re.compile(r"^[0-9]+:[0-9]+(\|[0-9]+)*$")
  
  @staticmethod
  def ValidateDemo(demodata):
    return Comment.demo_re.search(demodata) != None

  @staticmethod
  def get_by_comment_id(map, comment_id):
    return Comment.get_by_id(parent=map, ids=comment_id)

  @staticmethod
  def MatchesBadwords(text):
    words = set([x.lower().strip(" !?;:.") for x in text.split()])
    if words.intersection(Comment._badwords):
      return True
    else:
      return False

  @staticmethod
  def new(map_key, author, title, text, demodata):
    def DoNew():
      map = Map.get(map_key)
      comment = Comment(parent=map,
                        author=author,
                        title=title,
                        text=text,
                        demodata=demodata)
      if Comment.MatchesBadwords(title) or Comment.MatchesBadwords(text):
        comment.reported = True
      comment.put()

      if not map.first_unread_comment:
        map.first_unread_comment = comment.lastupdated
        user_key = map._user
      else:
        user_key = None
      map.comment_count += 1
      map.put()
      return (comment, user_key)

    def DoUpdateUnreadCount(user_key):
      user = User.get(user_key)
      user.num_unread_maps += 1
      user.put()

    comment, user_key = db.RunInTransaction(DoNew)
    if user_key:
      db.RunInTransaction(DoUpdateUnreadCount, user_key)
    return comment


class Vote(db.Model):
  value = db.IntegerProperty(required=True)
  timestamp = db.DateTimeProperty(required=True, auto_now_add=True)


class Favorite(db.Model):
  added = db.DateTimeProperty(required=True, auto_now_add=True)
  map_id = db.IntegerProperty()

  @staticmethod
  def Exists(user_key, map_key):
    fav_key = db.Key.from_path("Favorite", map_key.name(),
                               parent=user_key)
    return Favorite.get(fav_key) is not None

  def map_key(self):
    return db.Key.from_path("Map", self.key().name())
